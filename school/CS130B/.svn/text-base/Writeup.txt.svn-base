Project Writeup
Evan Senter
Computer Science 130B
University of California: Santa Barbara
March 6th, 2008

[Project Description]

	The objective task of this program is to provide answers to the Steiner Tree problem in a closed fashion. The Steiner Tree problem is very similar to that of the Minimum Spanning Tree problem which asks for, given a collection of edges forming a undirected weighted connected graph and a subset of vertices within the graph, return the subgraph representing the minimum summed weight of edges while maintaining the connectivity of the subgraph. The difference between this problem and the Minimum Spanning Tree is that in the Steiner Tree, edges that include vertices not in the subset the algorithm is providing a solution for may be used if they decrease the total weight of the subtree.

	The program is intended to be operated in a closed fashion - the same data structure that the algorithm takes in as input it returns as output, allowing for the user to chain together successive calls to the methods if they desire. In order to enforce this restriction, it is neccessary to develop a comprehensive data structure that can represent not only the graph on which the problem is applied but the operations needed during runtime. The solution used to overcome this design restriction was the merger of two separate structures, a minimum heap and a sorted list.

	The minimum heap is, from an interface perspective, a sorted list of elements of which the minimum in the sest can be easily accessed and removed (With the necessary operations to ensure that the next smallest element is promoted to the position of its removed predecessor). It is implemented as an array - convienently possible because the maximum size needed can be inferred ahead of time. The minimum heap is used as a container for all the edges in the current graph, and directly coupled with the second data structure, a sorted list.

	The sorted list had to solve a different problem than the minimum heap did, as the list is used to hold all of the current vertices. Thus, while the edges container needed to support the operations insert and getMinimum (Mistakenly named deleteMax() in the Edges.h file, though it returns the minimum weighted edge - Evan) with greatest possible efficency, the vertices list is small relative to the number of edges in the general case, and the operations findVertex, insert and remove are of more pressing importance in this data structure. Therefore, it was chosen to use the Vector STL class, a linked list wrapper that permits inserts anywhere within the list, lookup by index, and a scalable size - convienent when vertices are dynamically being added and removed to properly reflect the current state of the Edges minimum heap (Reffered to as EdgeHeap from here on). There is a performance hit taken for using a dynamically scalable data structure such as a list rather than a fixed size array, but in the interest of ease of implementation, the trade off seemed proportionally reflective of the relative gain.

	C++ was the language chosen to write this project in, and where possible I have tried to adhere to the design philosophies of object-oriented programming. There are classes for vertices, edges, graphs, and the methods (algorithms) applied to the Steiner Tree problem. Following the style of C++ programs, the data structures were written into header files with include guards while the main controller and the methods wrapper exist in .cpp files instead, reflecting the data flow of the program.

	As a final note on this implementation of the Steiner Tree problem, there is an underlying concept at the crux of finding a minimum path - and that is the concept of an l-path. The shortest lexiographic path or edge is an issue that arises when you have more than one possible path (or edge) of least weight and you are forced to chose amongst ties. In an l-path, the vertices are ordered in the progression of the path, from starting vertex (i) to the finishing vertex (j). If there are n paths in question of equal weight going from (i) to (j), compare the value of the vertices from i + 1 to j - 1 (One doesn't need to compare i and j because all paths must start and end there respectively). If at any point there is an vertex at index (k) such that the value of the vertices in all possible paths is not equal (ie we have a path from 1, 3, 5 and 1, 2, 5 and are considering index 1 (0 indexed) in the paths), the shortest l-path is the one with the minimum vertex at index (k). It is also important to note that a situation will not arise where there is no index k such that the values of the vertices between two possible shortest paths are equal, because then one is just considering two seperate instances of the same path.

	The way in which paths are represented internally is a vector of Edges. By doing it in this manner, it's easy to find the total path weight (By iterating over the edges) and what vertices are present. All paths mentioned in the implementation section are constructed in this fashion, unless explicitly stated otherwise. As the paths are returned from the call to shortestPath in Edges.h, the total weight is determined and appended to the end of the vector as a sentinel edge from vertex -1 to vertex -1 with a weight equal to the total weight of the path.

[Project Implementation]

	Data flow: Input -> (main.cpp) -> instantiate an EdgeHeap from (Edges.h) -> pass to (Methods.cpp) to execute algorithm -> new EdgeHeap returned to (main.cpp) representing the Steiner Tree -> Output

> main.cpp - This is the file that manages the input and output of data to the rest of the program. It uses the <stdio.h> header file for taking input and output, as the scanf() method is easy to use when one isn't concerned with the fidelity of user input and assumes it to be formatted correctly. After reading the first line of input, main.cpp instantiates an EdgeHeap (from Edges.h) of the proper size and proceeds to alternate reading a line of input and inserting it into the EdgeHeap while there is still more input to be had. After the EdgeHeap (we will call this the fullTree) has had all the edges inserted, the program flow branches based on the preferred format of the output, taking one path if SAMBA visualization has been requested by the user (The seperate path is necessary because the SAMBA visualization requires coordinates in addition to vertex ids for edges) and another otherwise. A simple if/else structure is used to synchronise method calls to their corresponding methods and the format of the output with the requested type.

> Methods.cpp - This is the class that housed all of the individual methods used to solve the Steiner Tree problem. On the global level, each method takes and returns an EdgeHeap and when the Methods class is initialized, it takes the fullTree as a parameter on which to operate.

	(Greedy Methods)

	shortestPath -- The shorest path method was the first one that I wrote, and the foundation on which the others were built. Its execution is very simple; it begins with a tree containing the lowest vertex, and maintains a collection of vertices not present in the newTree but should be (The vertices from 1 <= i <= k) and falls into a double for loop, searching for the smallest l-path and adding its components to the newTree.  This path, once found is added to newTree and the vertices are updated accordingly until the newtree contains all vertices from 1 to k, and then the while loop terminates. At the termination of the while loop, we have a Steiner Tree and return it as an EdgeHeap.

	closestPair -- Closest pair was more challenging to get working and never did run without bugs, but it's approach to the solution wasn't as well formed to the interface for the EdgeHeap. This method starts by breaking up all the vertices into individual trees, and while there are more than one tree in the forest performs the following block. For all unique pairs of vertices in the forest we find the smallest l-path between them and then select the minimum of minimums. This path, and the tree that it goes to are both added to the tree that it came from, so that there is now one less tree in the forest. When the while condition is finally not met there is one tree in the forest only, and this is our Steiner Tree that is returned.

	smallestEdge -- Both smallest edge and the dynamic programming methods presented a unique problem that I could never quite solve, and in the following section I will explain both the problem, the solution and the issue with it. Smallest edge operates in a similar fashion to the other two greedy methods, but with a twist; it needs to check for cycles. This proved to be quite an issue as I had no off-the-bat cycle support in my data structure. My solution was to perform an all pairs shortest path and look for cycles in the returns, which could be seen as loops in the vertices. The glaring issue with this is the computation expense of performing an operation like that, and for that reason I was incapable of getting either smallestEdge or dynamicProgramming to work properly. The method is to start with an empty tree and insert the smallest l-edge from fullTree into newTree in while there aren't any cycles formed by the insertion of this minimum edge. The minimum heap structure for edges lends itself greatly to the ease with which the smallest l-edges are found. It then goes through a cleanup phase, where any edges not necessary for the connectedness of the newTree are systematically removed until no more such edges exist.

	customMethod -- The custom method is very similar to shortestPath, so I will only expand on it breifly. My goal with the customMethod was to represent paths as trees rather than vectors. For this I initially wrote a second shortestPath method that returned EdgeHeaps rather than vector <Edge>, but found it easier in the end to write a second wrapped that convered the path to an EdgeHeap. A number of additional methods were required in Edges.h to make the transition between data structures simple, but the complexity cost of converting turned out in the end to not outweigh the benefits of doing EdgeHeap EdgeHeap merges.

	(Divide and Conquer Methods)

	divideAndConquer -- The divide and conquer method has three parts; the base cases, the divide section and the conquer section. The two base cases are simple, if there is one vertex in the tree return a tree with just that vertex and if there are two vertices, return the tree with a l-path from one vertex to the other where the 'from' vertex is lower (in value) than the 'to' vertex. For the dividing, an operation similar to quicksort's pivot and partition is used. First we find the middle vertex so that we can partition out tree into two subtrees containing +-1 the same number of vertices. We then call divideAndConquer on each of these trees. In conquering, we first look to find an l-path from partition1 to partition2 (Recall that we're recursively splitting our trees into two subtrees). These two partitions and the l-path between them are then merged into a new tree called mergeTree. All that is left to be done is remove all the edges forming cycles (In the same fashion as described in smallestEdge) and extraneous edges, then return. Once all the calls are completed we are left with a Steiner Tree that is of minimum span.

	(Dynamic Programming Methods)

	Recomputation - Recomputation is the reexecution of methods to find information that we have already found. It is in most cases an unnecessary task that simplifies the code, but by cleverly storing intermediary values it is possible to avoid all unnecessary recomputation and increase performance.

	dynamicProgramming -- Let me start by noting that I wasn't able to get this method to compile, and it had to be removed. The concept of dynamic programming is intuitively similar to that of recursive programming, the difference lying in the fact that recursive calls have an expensive overhead cost. In order to alleviate this issue and reduce the running time of recursive algorithms, we can take advantage of data structures and variables to store intermediary data (With emphasis on data structures that model information recursively, such as stacks). The problem I ran into was once again managing cycles, and couldn't manage to find an elegant solution to the problem. This method first finds for all pairs, the shortest l-path between them. We then build a minimum cost spanning tree using only the necessary shortest paths and execute the following two actions. First, we remove all cycles by order of weight, and finally we remove all unnecessary edges from the tree. In the end, we have a Steiner Tree and return it accordingly.

> Edges.h - For brevity's sake, as mentioned before Edges.h contains a minimum heap and a sorted list. The notable methods supported by this graph wrapper is insert and delete edges (Which manages the vertices accordingly), shortestPath (Which uses a version of Dijkstra's that terminates when the target vertex is marked as known) and various accessor methods. The shortestPath method is the most complex and calls out to updateVertices to actually update the information in the vertices for each cycle of Dijkstra's algorithm.

> Edge.h - Edge is a simple wrapper for an edge between two vertices. As integers it contains the 'from' and 'to' vertices and the weight between them, and in the case of the SAMBA constructor the x and y coordinates. Where needed, accessors and mutators are available for modifying the edge data.

> Vertex.h - Like Edge, Vertex.h is a wrapper for a vertex. I initially used just integers to represent vertices but during the implementation of Dijkstra's, it became clear that writing a class to model the previous, known and distance aspects of vertices needed to run shortestPath, it would be easiest to have all of the necessary features baked into one Vertex class.

> test.txt and test2.txt - These are the files that I used for testing. I was able to get shortestPath working on both the data sets, and had intermittent luck running the other methods.

> Makefile - A very simple makefile that I used to build my project. I maintained the include statements within the files in a manner that made it unnecessary to have compile orders, but the make clean and make test features were convienent to simulate an on-the-fly testing environment.

[Results, Conclusions]

	In closing, I was a little displeased with the lack of success I had in actually getting the methods to work appropriately. I compiled frequently and therefore never had any syntactical errors of note, but some of the logical errors in Dijkstra's took days to iron out, and some are still present. I performed heavy testing on the test.txt file and because I only had repeated success with the shortestPath method, I can't really speak on the issue of time complexity.

	As a final note, I had issues with SAMBA because I couldn't get the SAMBA Edge constructor to play nice with EdgeHeap, but in main.cpp there is a section that prints (what I believe to be) the right SAMBA commands to render the graph on screen. If I had the opportunity to do this project again, I would place even heavier focus initially on formulating an interface for the graph that allowed 7 different variations on the Steiner Tree problem to execute on it. Although not all the methods work, I am pleased with the quality of code that I produced (Especially when considering my lack of experience with C++ when compared to a language I more frequently use, Ruby) and enjoyed the opportunity to brush up on my C/C++ skills on a very relevant problem to Computer Science.
